#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <map>

// Include GLEW
#include <GL/glew.h>

// Include GLM
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/gtx/quaternion.hpp>

#include "vecTypes.h"
#include <common/shader.h>
#include <common/texture.h>
#include <common/objloader.h>

typedef enum {
  shapeOBJ = 0,
  shapeAXES = 1,
  shapeRECT = 2
} mvShapeType;
  
// This is a generic class to hold a shape to be drawn.  The actual
// vertex coordinates of the shape are supplied in a sub-class, which
// might hold a line, cylinder, rectangle, OBJ file, whatever.  There
// is a load() method for getting vertices and texture coordinates and
// whatever else ready, and a draw() method for the frame updates.
//
// This is meant to work with modern OpenGL, that uses shaders, and
// there are accompanying mvShaderSet and mvLights classes to manage
// those aspects of constructing a scene.  The mvShaderSet object is
// linked from mvShape largely for access to the programID.
//
// The shaders themselves are not included in this object because many
// objects will use the same shader.  The shader code will have to be
// specifically referenced in the load() and draw() methods here.  I
// have not come up with a clever way to avoid this, only clunky ones.
// So the program that calls this should keep three separate lists:
// the objects in the scenes, the shaders used to render them, and the
// lights used by the shaders.
//
// This class imposes a small number of restrictions on the shader
// code itself, mostly the names of things.  These are specified in
// the setupDefaultName() method.  Setting things up for the number of
// lights is also something that needs to be configured carefully.
// See the shader.h file for more about that.
//
class mvShape {
protected:

  mvShapeType _type;

  // This contains a pointer to the shader to be used and also keeps track of
  // all the OpenGL flibbertygib that corresponds to that shader.
  mvShaderContext _shaderContext;

  GLuint _arrayID;

  // The actual shape data is stored here.
  std::vector<MVec3> _vertices;
	std::vector<MVec2> _uvs;
	std::vector<MVec3> _normals;
	std::vector<MVec3> _colors;

  MVec3 _position;
  MVec3 _scale;
  MQuat _rotQuaternion;
  
  // This is the matrix that controls the shape's position,
  // orientation, and scale, generated by the above vectors.
  MMat4 _modelMatrix;
  bool _modelMatrixNeedsReset;

  virtual std::string print() const;
  friend std::ostream & operator<<(std::ostream &os, const mvShape& iShape);

  // This is just a central place to put all the names that will be
  // relevant to your shaders.
  void setupDefaultNames();
  
public:
  mvShape(mvShapeType type, mvShaderSet* shaders, mvTexture* texture);
  virtual ~mvShape();

  void setShaderContext(mvShaderContext shaderContext) {
    _shaderContext = shaderContext;
  };
  
  static void printMat(std::string name, MMat4 mat);

  virtual void load() = 0;
  virtual void draw(MMat4 ViewMatrix, MMat4 ProjectionMatrix) = 0;

  // These are here to specialize in the subclasses.  There are three, so you
  // can specialize depending on whether the subclass represents a 1D, 2D, or
  // 3D shape.  Just ignore the two that don't fit.
  virtual void setDimensions(GLfloat a) {};
  virtual void setDimensions(GLfloat a, GLfloat b) {};
  virtual void setDimensions(GLfloat a, GLfloat b, GLfloat c) {};

  mvShaderContext getShaderContext() { return _shaderContext; };
  
  mvShapeType getType() { return _type; };

  // Position, rotation, scale control mutators.
  void setPosition(MVec3 position) {
    _position = position;
    _modelMatrixNeedsReset = true;
  };
  void setPosition(GLfloat x, GLfloat y, GLfloat z) {
    setPosition(MVec3(x, y, z));
  };
  void setScale(MVec3 scale) {
    _scale = scale;
    _modelMatrixNeedsReset = true;
  };
  void setRotation(MQuat rotQuaternion) {
    _rotQuaternion = rotQuaternion;
    _modelMatrixNeedsReset = true;
  };
  void setRotation(MVec3 pitchYawRoll) {
    _rotQuaternion = MQuat(pitchYawRoll);      
    _modelMatrixNeedsReset = true;
  };
  
  MVec3 getPosition() { return _position; };
  MVec3 getScale() { return _scale; };
  MQuat getRotQuaternion() { return _rotQuaternion; };
  MVec3 getPitchYawRoll() { return glm::eulerAngles(_rotQuaternion); };
  
  MMat4 getModelMatrix();

};

class mvShapeRect : public mvShape {
protected:

  GLfloat _width, _height;
  
  // Some of these should move into the parent class.  Also the destructor.
  GLuint _lightPositionID;
  GLuint _lightColorID;

  void initVertices();

  std::string print() const;
  friend std::ostream & operator<<(std::ostream &os, const mvShapeRect& iShape);

  
public:
 mvShapeRect(mvShaderSet* shaders, mvTexture* texture) :
  mvShape(shapeRECT, shaders, texture) {
    // Set default rectangle dimensions.
    _width = 1.0f;  _height = 1.0f;
  };

  void setWidth(GLfloat width) { _width = width; };
  void setHeight(GLfloat height) { _height = height; };
  void setDimensions(GLfloat width, GLfloat height) {
    _width = width; _height = height; };

  GLfloat getWidth() { return _width; };
  GLfloat getHeight() { return _height; };
  
  void load();
  void draw(MMat4 ViewMatrix, MMat4 ProjectionMatrix);
};

class mvShapeObj : public mvShape {
private:

  // Some of these should move into the parent class.  Also the destructor.
  GLuint _lightPositionID;
  GLuint _lightColorID;

  std::string _objFileName;
  
  std::string print() const;
  friend std::ostream & operator<<(std::ostream &os, const mvShapeObj& iShape);
  
public:
 mvShapeObj(mvShaderSet* shaders, mvTexture* texture) :
  mvShape(shapeOBJ, shaders, texture) {};

  void load();
  void draw(MMat4 ViewMatrix, MMat4 ProjectionMatrix);

  std::string getObjFile() { return _objFileName; };
  void setObjFile(std::string objFileName) { _objFileName = objFileName; };
};

class mvShapeAxes : public mvShape {
 private:
  
  static const int nCoordsComponents = 3;
  static const int nColorComponents = 3;
  static const int nLines = 3;
  static const int nVerticesPerLine = 2;
  static const int nFaces = 6;
  static const int nVerticesPerFace = 3;

  void expandAxesColors();
  void expandAxesVertices();

  std::string print() const;
  friend std::ostream & operator<<(std::ostream &os, const mvShapeAxes& iShape);
  
 public:
 mvShapeAxes(mvShaderSet* shaders, mvTexture* dummy) :
  mvShape(shapeAXES, shaders, NULL) {
    expandAxesVertices();
    expandAxesColors();
  }    
  
  void load();
  void draw(MMat4 ViewMatrix, MMat4 ProjectionMatrix);

};  

class mvShapeFactory {
 public:
  template<typename T>
    static mvShape* create(mvShaderSet* shaderSet, mvTexture* texture) {
    T* out = new T(shaderSet, texture);
    return (mvShape*)out;
  }

  typedef mvShape* (*createMvShapeCallback)(mvShaderSet* shaders,
                                            mvTexture* texture);

  mvShape* createShape(mvShapeType type,
                       mvShaderSet* shaders,
                       mvTexture* texture);

  bool registerShape(mvShapeType type, createMvShapeCallback creator);

  mvShapeFactory() {

    // Fill factory.
    registerShape(shapeOBJ, create<mvShapeObj>);
    registerShape(shapeAXES, create<mvShapeAxes>);
    registerShape(shapeRECT, create<mvShapeRect>);
    
  }
  
 private:
  typedef std::map<mvShapeType, createMvShapeCallback> callbackMap;
  callbackMap _callbacks;

  std::string print() const;
  friend std::ostream & operator<<(std::ostream &os, const mvShapeFactory& iShape);

};

/// TBD: Deleting the shader programs needs to be addressed. Also the
/// detach* thing

// Next, 
